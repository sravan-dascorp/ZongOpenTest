using System;
using System.Collections;
using UnityEngine;



//this class deals with player interaction and animations
public class PlayerActions : MonoBehaviour //////, IActionable
{
     // Start is called before the first frame update

     Inventory inventory;
     [SerializeField] Animator animator;
     [SerializeField] Transform hand; //for spawning itemmodel whne pickup
     [SerializeField]  LayerMask interactableLayer;
     FirstPersonController firstPersonController;
     void Start()
     {
          inventory = GetComponent<Inventory>();

          firstPersonController = GetComponent<FirstPersonController>();
     }


     void Update()
     {
            FocusRaycast();
          if (pendingActionRequest == ActionRequest.none || pendingActionRequest == ActionRequest.empty) return;
          if (Input.GetKeyDown(KeyCode.E))
          {
               if (currentInteractable != null)
               {

                    if (pendingActionRequest == ActionRequest.itemDeposit)
                    {
                         UIManager.Instance.ShowInventory(ItemType.instrument, true); //for now only handles instruemnts
                    }
                    else if (pendingActionRequest == ActionRequest.itemPickUP)
                    {
                         Items_SO item = currentInteractable.GetItem();
                         var go = SpawnItemModelInHand(item.Prefab);
                         StartCoroutine(this.StartPickUpAction(currentInteractable.GetPosition(), () => { inventory.AddItem(item); Destroy(go); }));
                         CheckPossibleAction();
                    }





               }
          }


        
     }


     IEnumerator StartPickUpAction(Vector3 pickObjPos, Action OnFinishAnimation)
     {
          // TurnPlayerToPOs(pickObjPos);
          // yield return GetComponent<FirstPersonController>().LookAtPosCoroutine(pickObjPos);
          animator.SetTrigger("pickUp");
          yield return new WaitForSeconds(2f);
          OnFinishAnimation?.Invoke();
     }
     ActionRequest pendingActionRequest = ActionRequest.empty;
     // Ipickables currentPendingPickable ;
     IInteractable currentInteractable;
     [SerializeField] float focusRaycastDistance;

     GameObject SpawnItemModelInHand(GameObject itemModel)
     {
          var itemInstance = GameObject.Instantiate(itemModel);
          itemInstance.transform.position = hand.position;
          itemInstance.transform.SetParent(hand);
          return itemInstance;
     }





     private void OnTriggerEnter(Collider other)
     {
          Debug.Log(other.gameObject);
          if (!other.gameObject.CompareTag("Interactable")) return;
          Debug.Log(other.gameObject);
          if (other.gameObject.TryGetComponent<IInteractable>(out IInteractable interactable))
          {
               currentInteractable = interactable;
               CheckPossibleAction();
               return;
          }

     }
     private void OnTriggerExit(Collider other)
     {
          currentInteractable = null;
          pendingActionRequest = ActionRequest.none;
          UIManager.Instance.ShowActionMessage("", false);
     }



     public void OnItemSelected(Items_SO item)//  :0  //call when an iteem is selected
     {
          if (pendingActionRequest == ActionRequest.itemDeposit)
          {
               if (currentInteractable.CheckItemAcceptable(item))
               {
                    currentInteractable.AddItem(item);
                    inventory.RemoveItem(item);
                    CheckPossibleAction(); //get new request
               }
               else
               {
                    UIManager.Instance.ShowDevMessage("item not Accepted");
                    //error sound
                    //
               }
          }
          else
          {
               //well whatever to do when an item selected

          }
     }

     private void CheckPossibleAction()
     {
          pendingActionRequest = currentInteractable.GetActionRequestType();        //possible bug...none condition>>check
          if (pendingActionRequest != ActionRequest.empty && pendingActionRequest != ActionRequest.none)//if only action exist display
          {
               UIManager.Instance.ShowActionMessage(currentInteractable.GetActionRequestDiscription(), true);
               ///
          }
          else
          {
               if (currentInteractable.DisableIfActionsEmpty) currentInteractable.Disable();
               currentInteractable = null;
               pendingActionRequest = ActionRequest.none;
               UIManager.Instance.ShowActionMessage("",false);
          }


        // UIManager.Instance.ShowActionMessage("",pendingActionRequest == ActionRequest.empty || pendingActionRequest == ActionRequest.none);
     }



     void FocusRaycast() //just a quick after thought..so not optimal
     {
      
          Ray ray = new Ray(firstPersonController.GetEyesTransform().position, firstPersonController.GetEyesTransform().forward.normalized * 100);
          Debug.Log( "dfdfdf" + firstPersonController.GetEyesTransform().forward);
          RaycastHit hit;

          if (Physics.Raycast(ray, out hit, focusRaycastDistance,interactableLayer))
          {
               IInteractable interactable = hit.collider.GetComponent<IInteractable>();

               if (interactable != null)
               {
                    interactable.OnFocused();
               }
          }

         // Debug.DrawRay(ray.origin, ray.direction * focusRaycastDistance, Color.red);
     }

}






//      public void ProcessItemWithActionRequest(Items_SO item)  //just  a temp solution ,taht checks if any action request and match it with the item selected to 
//     {
//           switch (pendingActionRequest)
//           {
//                case ActionRequest.empty:
//                     return;
//                case ActionRequest.itemPickUP:


//                default:
//                     return;
//           }
//     }




public enum ActionRequest { itemDeposit, itemPickUP, pressButton, push, empty, none } //todo:; move to  on seprate file..?